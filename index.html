
<!doctype html>
<html lang="en">
	<head>
		<title>Three.js Equalizer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				text-align:center;
			}
		</style>

		<link href="js/gui/gui.css" media="screen" rel="stylesheet" type="text/css" />
		<script src="js/gui/gui.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/RequestAnimationFrame.js"></script>
		<script src="js/Stats.js"></script>
		<script src="js/Three.js"></script>
		<script src="js/beatdetektor.js"></script>
		<script src="js/dsp.js"></script>

	</head>
	<body>

	  <script>

	  function animate() {

      render();
			requestAnimationFrame( animate );
			stats.update();

		}
	  </script>

	  <audio id="main-audio" src="ungirthed.ogg" controls="true" onplay = "animate()" style="width:512px; height:30px; position:absolute; left:30%;" autoplay="true"></audio>

  	<script>

			var audio,
				audioOutput,
				frameSize = 2048,
				bufferSize = frameSize / 2,
				sampleRate = 44100,
				signal = new Float32Array(bufferSize),
				peak = new Float32Array(bufferSize),
				fft = new FFT(bufferSize, sampleRate),
				bd = new BeatDetektor(60, 90),
				vu = new BeatDetektor.modules.vis.VU(),
				m_BeatCounter = 0,
				m_BeatTimer = 0,
				clearClr = [0,0,1],
				ftimer = 0,
				cut, res, signStep=0;
			var size = 15, res = 100, sizeres = size * res, halfsizeres = sizeres / 2;
			var buffer1 = [], buffer2 = [], temp;
			var grid = [], plane, peakMeshes = [];
			var scene, camera, light, renderer;
			var geometry, material;
			var mouse, projector, ray, intersects = [], HSV = [];
			var stats;
			var lightBall = null;
			var guiSettings;
			var step = 1;
			var timestep = 0, timestep2 = 0;
			var color1 = 0xCCFF00, color2 = 0xFF0048;
      var container;
      var oldLight;
      var peakCubes = [];
      var controls;

      var blue_texture = THREE.ImageUtils.loadTexture( "textures/blue_splat.jpg" );
      var grid_texture = THREE.ImageUtils.loadTexture( "textures/grid.jpg" );
      var rust_texture = THREE.ImageUtils.loadTexture( "textures/rust.jpg" );
      var plane_texture = rust_texture;

			audio = document.getElementById('main-audio');
			audio.addEventListener('MozAudioAvailable', audioAvailable, false);

			function audioAvailable(event) {
				var frameBuffer = event.frameBuffer;
				timestamp = event.time;

		    // de-interleave and mix down to mono
				signal = DSP.getChannel(DSP.MIX, frameBuffer);

				if (audioOutput instanceof Audio) { // write out to the filter
					lp12.process(signal); // apply LP12 Filter
					audioOutput.mozWriteAudio(signal);
				}

				//perform forward transform
				if(!audio.paused){
					// beat detection
					bd.process( timestamp, fft.spectrum );

					if (bd.win_bpm_int_lo) {
						m_BeatTimer += bd.last_update;

						if (m_BeatTimer > (60.0/bd.win_bpm_int_lo)) {
							m_BeatTimer -= (60.0/bd.win_bpm_int_lo);
							m_BeatCounter++;
						}
					}

					fft.forward(signal);
					analyze(event.frameBuffer);
				}
			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				setupGUI();

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 8000 );
				camera.position.x = 1000;
				camera.position.y = 1000;
				camera.position.z = 1000;
				camera.lookAt(new THREE.Vector3(500,500,0));
				scene.add( camera );

        controls = new THREE.TrackballControls( camera );
        controls.target.set(800,0,0);
      	controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				controls.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];


        scene.add( new THREE.AmbientLight( 0x808080 ) );

				light = new THREE.SpotLight( 0xffffff, 2 );
				light.castShadow = true;
				light.position.set( 400, 300, 2000 );
				light.target.position.set( 600, 0, -100 );
			  scene.add( light );

				lightBall = new THREE.Mesh(new THREE.SphereGeometry(10,10,10), new THREE.MeshLambertMaterial( { color: 0x4694C8} ));
				lightBall.visible = false;
				lightBall.position.set(light.position.x, light.position.y, light.position.z);
        // scene.add(lightBall);

				geometry = new THREE.CubeGeometry( size, size, size );
				geometry.applyMatrix( new THREE.Matrix4().setTranslation( 0, size / 2, 0 ) );

				var hsv;

				for ( var i = 0, l = res * 1; i < l; i ++ ) {

					material = new THREE.MeshPhongMaterial( { ambient: 0x050505, color: 0xffffff, specular: 0x555555, shininess: 30 } )
					hsv = (1.13*l-i)/res;
					material.color.setHSV(hsv, hsv, hsv);

					cube = new THREE.Mesh( new THREE.CubeGeometry( size, 2, size ), material );
					cube.position.x = size + ( ( i % res ) * size );
					cube.castShadow = false;
					cube.wireframe = true;
					HSV.push(hsv);
					if (guiSettings.dropdownCubes) {
             scene.add( cube );
          }
          peakMeshes.push( cube );

          cube = new THREE.Mesh( geometry, material );
          cube.position.x = size + ( ( i % res ) * size );
          cube.castShadow = true;
          cube.receiveShadow = false;
          scene.add( cube );
          grid.push( cube );
				}

        setupPlane();
        setupStars()

				var position = grid[Math.floor(grid.length/2)].position;

				renderer = new THREE.WebGLRenderer( {antialias:"true"} );
				renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMapEnabled = true;
				container.appendChild( renderer.domElement );

				mouse = new THREE.Vector3( 0, 0, 1 );
				projector = new THREE.Projector();
				ray = new THREE.Ray( camera.position );

			}

      function switchLights(showShadows) {
        var tempPos = light.position;
        var tempTar = light.target.position;

        var newLight = new THREE.SpotLight( 0xffffff, 1.5 );
				newLight.castShadow = showShadows;
				newLight.position.set(tempPos.x, tempPos.y, tempPos.z);
				newLight.lookAt(tempTar);

        scene.remove( light );
        light = newLight;
        scene.add( light );

        scene.objects.forEach(function(item) {
             renderer.initMaterial(item.materials[0], scene.lights, false, item.geometry);
        });

        if(showShadows) {
          scene.remove(plane)
          setupPlane();
        }
      }

      function setupPlane() {
        plane_texture.wrapT = plane_texture.wrapS = THREE.RepeatWrapping;
        geo = new THREE.PlaneGeometry( 2*sizeres, 2*sizeres );
        plane = new THREE.Mesh( geo, new THREE.MeshBasicMaterial( {map: plane_texture}));
        plane.position.x = halfsizeres;
        plane.position.z = 0;
        plane.rotation.x = - 90 * Math.PI / 180;
        plane.visible = true;
        plane.receiveShadow=true;
        scene.add( plane );
      }

      function setupStars() {
        var star_texture = THREE.ImageUtils.loadTexture('textures/sphere_star_half.png');
        star_texture.wrapS = star_texture.wrapT = THREE.RepeatWrapping;
        var sphereMaterial = new THREE.MeshBasicMaterial({map: star_texture});
        var sphereGeo = new THREE.SphereGeometry(3000, 10, 10);
        var sphere = new THREE.Mesh( sphereGeo, sphereMaterial);
        sphere.position.set(0,0,0);
        sphere.doubleSided = true;
        scene.add( sphere );
      }

      function switchPeaks(display) {
        if(display) {
          peakMeshes.forEach(function(item) {
            scene.add(item);
          })
        } else {
          peakMeshes.forEach(function(item) {
            scene.remove(item);
          })
        }

      }

			function setupGUI(){

				gui = new GUI();
				gui.autoplace = true;
				guiSettings = {
					track: 3,
					plane: 1,
					step: 1,
					orbitCamera: false,
					colormap: false,
					shadows: true,
					dropdownCubes: true
				};

        gui.add(guiSettings, 'plane').options({'Rust': 0, 'Grid': 1, 'Blue.ogg': 2 }).listen().onChange(function(newVal){
          switch(newVal){
            case 0:
              plane_texture = rust_texture;
              break;
            case 1:
              plane_texture = grid_texture;
              break;
            case 2:
              plane_texture = blue_texture;
              break;
          }
          scene.remove(plane);
          setupPlane();
        });

				gui.add(guiSettings, 'track').options({'Revolve.ogg': 0, 'VQ.ogg': 1, 'FilterFade.ogg': 2, 'michael.ogg': 3, 'Biggie.ogg': 4 }).onChange(function(newVal){

					switch(newVal){
						case 0:
						if(audio.src.indexOf('Revolve') === -1){
							audio.pause();
							fft = new FFT(bufferSize, sampleRate),
							audio.src = 'Revolve.ogg';
							audio.play();
						}
						break;
						case 1:
						if(audio.src.indexOf('VQ') === -1){
							audio.pause();
							fft = new FFT(bufferSize, sampleRate),
							audio.src = 'VQ.ogg';
							audio.play();
						}
						break;
						case 2:
						if(audio.src.indexOf('FilterFade') === -1){
							audio.pause();
							fft = new FFT(bufferSize, sampleRate),
							audio.src = 'FilterFade.ogg';
							audio.play();
						}
						break;
						case 3:
						if(audio.src.indexOf('michael') === -1){
							audio.pause();
							fft = new FFT(bufferSize, sampleRate),
							audio.src = 'michael.ogg';
							audio.play();
						}
						break;
						case 4:
						if(audio.src.indexOf('Biggie') === -1){
							audio.pause();
							fft = new FFT(bufferSize, sampleRate),
							audio.src = 'Biggie.ogg';
							audio.play();
						}
						break;
					}

				});

				gui.add(guiSettings, 'step').options({'1': 1, '2': 2, '3': 3, '4': 4, '5': 5 });

				gui.add(guiSettings, 'colormap');

				gui.add(guiSettings, 'orbitCamera');

				gui.add(guiSettings, 'shadows').listen().onChange(function(){
					switchLights(guiSettings.shadows);
				});

				gui.add(guiSettings, 'dropdownCubes').listen().onChange(function(){
				  switchPeaks(guiSettings.dropdownCubes)
				});
			}

			function interpolateColorsCompact( a, b, Number ){
			   	var MASK1 = 0xff00ff;
				var MASK2 = 0x00ff00;

				var f2= Math.floor(256 * Number);
				var f1 = 256 - f2;

				return   ((((( a & MASK1 ) * f1 ) + ( ( b & MASK1 ) * f2 )) >> 8 ) & MASK1 )
				         | ((((( a & MASK2 ) * f1 ) + ( ( b & MASK2 ) * f2 )) >> 8 ) & MASK2 );

			}

			function analyze(framebuffer) {
				var speed = bd.win_bpm_int_lo;
				// calculate peak values
				var maxPeak = 1e-6;
				for ( var i = 0; i < peakMeshes.length; i++ ) {
					var avg = 0;
					for(var j = 0 ; j < 5 ; j++) {
						avg+=fft.spectrum[i*5+j]/5;
					}
				//equalize, attenuates low freqs and boosts highs
					 if ( peak[i] < avg *1000 ) {
						peak[i] = avg*1000;
					 }else {
						peak[i] *= 0.99; // peak slowly falls until a new peak is found
					}
					if(maxPeak < peak[i]*1000){
						maxPeak = peak[i]*1000;
					}
					peakMeshes[i].position.y = Math.min(peak[i]*size, 40*size);

				}

				var percent = 0;

				if(!audio.paused){

					for(var i = 0 ; i < grid.length ; i++){
						var avg = 0;
						for(var j = 0 ; j < 5 ; j++) {
							avg+=fft.spectrum[i*5+j]/5;
						}
						grid[i].scale.y = avg * 1000;
						grid[i].scale.y = Math.min(40, grid[i].scale.y);
						//grid[i].position.z = stepSign(200, i/100, speed);
						percent = Math.min(1.0, (grid[i].scale.y * size)/600);
						percent = Math.max(0,percent);

						if(guiSettings.colormap){
							interpC = interpolateColorsCompact(color1, color2, percent)
							grid[i].materials[0].color.setHex(interpC);
							peakMeshes[i].materials[0].color.setHex(interpC);
						}else{
							grid[i].materials[0].color.setHex(0xffffff);
						    grid[i].materials[0].color.setHSV(HSV[i], HSV[i], HSV[i]);
							peakMeshes[i].materials[0].color.setHex(0xffffff);
							peakMeshes[i].materials[0].color.setHSV(HSV[i], HSV[i], HSV[i]);
						}
					}
					signStep+=speed/10000;

					if(signStep % 2*Math.PI === 0){
						signStep = 0;
					}
				}
			}

			//increment
			function stepSign(scale, index, speed){

				return scale*Math.sin((signStep + index)*2*Math.PI);

			}

			function filter(framebuffer){
				frameCount++;
				cut.value = 2500 + Math.sin(frameCount/50) * 2400;
				res.value = 10 + Math.sin(frameCount/100) * 9;
			}

			function HandlePeaks(){
				for ( var i = 0; i < grid.length; i++ ) {
				//equalize, attenuates low freqs and boosts highs
					if ( peak[i] < fft.spectrum[i*step]*1000 ) {
						peak[i] = fft.spectrum[i*step]*1000;
					}else {
						peak[i] *= 0.99; // peak slowly falls until a new peak is found
					}

					peakMeshes[i].position.y = peak[i]*10;
				}
			}

			function render() {
				if(!audio.paused){
					if(guiSettings.orbitCamera){

						timestep+=0.25; timestep2 += 0.25;
						if(timestep > 360) timestep = 0;
						if(timestep2 > 360) timestep2 = 0;

						stepLight = {
							x : 60*size*Math.cos(timestep*Math.PI/180) + 400,
							y : 30*size*Math.cos(timestep*Math.PI/180)*Math.sin(timestep*Math.PI/180) + 600,
							z : 80*size*Math.sin(timestep*Math.PI/180) + 50
						};

						stepCamera = {
							x : 60*size*Math.cos(timestep2*Math.PI/180) + 800,
							y : 30*size*Math.cos(timestep2*Math.PI/180)*Math.sin(timestep2*Math.PI/180) + 800,
							z : 90*size*Math.sin(timestep2*Math.PI/180)
						};

						light.position.set( stepLight.x, stepLight.y , stepLight.z);
						lightBall.position.set(light.position.x,light.position.y,light.position.z);

						camera.position.set(stepCamera.x, stepCamera.y, stepCamera.z);

            position = grid[Math.floor(grid.length/2)].position;
            camera.lookAt(new THREE.Vector3(position.x, 100, position.z));

					}

          controls.update();
					renderer.render( scene, camera );
				}
			}

			if ( Detector.webgl ) {

				init();
				animate();

			} else {
				document.body.appendChild( Detector.getWebGLErrorMessage() );
			}

		</script>


		</body>
</html>